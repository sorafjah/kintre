import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'firebase/auth';
import { getFirestore, doc, setDoc, onSnapshot, getDoc, collection, setLogLevel } from 'firebase/firestore';
import { ChevronLeft, ChevronRight, Leaf, Dumbbell, Plus, X } from 'lucide-react';

// --- Firebase Configuration ---
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// --- Constants ---
const DEFAULT_STRETCH_ITEMS = ['首', '肩', '背中', '腰', '手首', '足首'];
const DEFAULT_WORKOUT_ITEMS = ['スクワット', 'ランジ', '背筋', '腕立て', '片足おじぎ', '腹筋'];
const CONFIG_DOC_PATH = `artifacts/${appId}/public/data/app_config/main`;

// --- Helper Functions ---
const formatDate = (date) => date.toISOString().split('T')[0];
const getJapaneseDateString = (date) => new Intl.DateTimeFormat('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'short' }).format(date);

// --- Main App Component ---
export default function App() {
    const [db, setDb] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);
    const [currentDate, setCurrentDate] = useState(new Date());
    const [records, setRecords] = useState({});
    const [isCalendarVisible, setCalendarVisible] = useState(false);
    const [stretchItems, setStretchItems] = useState(DEFAULT_STRETCH_ITEMS);
    const [workoutItems, setWorkoutItems] = useState(DEFAULT_WORKOUT_ITEMS);
    const [editModal, setEditModal] = useState({ isOpen: false, type: '', item: '', isNew: false });

    useEffect(() => {
        if (!Object.keys(firebaseConfig).length) return;
        try {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const firestore = getFirestore(app);
            setDb(firestore);
            setLogLevel('debug');
            const unsubAuth = onAuthStateChanged(auth, async user => {
                if (user) {
                    setUserId(user.uid);
                    setIsAuthReady(true);
                } else {
                    if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
                    else await signInAnonymously(auth);
                }
            });
            return () => unsubAuth();
        } catch (error) { console.error("Firebase init error:", error); }
    }, []);

    const updateItemsConfig = useCallback(async (newStretch, newWorkout) => {
        if (!db) return;
        const configDocRef = doc(db, CONFIG_DOC_PATH);
        const data = {};
        if (newStretch) data.stretchItems = newStretch;
        if (newWorkout) data.workoutItems = newWorkout;
        await setDoc(configDocRef, data, { merge: true });
    }, [db]);
    
    useEffect(() => {
        if (!isAuthReady || !db || !userId) return;
        const configDocRef = doc(db, CONFIG_DOC_PATH);
        const unsub = onSnapshot(configDocRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                setStretchItems(data.stretchItems || DEFAULT_STRETCH_ITEMS);
                setWorkoutItems(data.workoutItems || DEFAULT_WORKOUT_ITEMS);
            } else {
                updateItemsConfig(DEFAULT_STRETCH_ITEMS, DEFAULT_WORKOUT_ITEMS);
            }
        });
        return () => unsub();
    }, [isAuthReady, db, userId, updateItemsConfig]);

    useEffect(() => {
        if (!isAuthReady || !db || !userId) return;
        const collectionPath = `artifacts/${appId}/public/data/training_records`;
        const colRef = collection(db, collectionPath);
        const unsub = onSnapshot(colRef, snapshot => {
            const newRecords = {};
            snapshot.forEach(doc => { newRecords[doc.id] = doc.data(); });
            setRecords(newRecords);
        });
        return () => unsub();
    }, [isAuthReady, db, userId]);

    const changeDate = (days) => {
        setCurrentDate(prev => {
            const newDate = new Date(prev);
            newDate.setDate(newDate.getDate() + days);
            return newDate;
        });
    };

    const handleItemToggle = async (type, item) => {
        if (!isAuthReady || !db || !userId) return;
        const dateKey = formatDate(currentDate);
        const docRef = doc(db, `artifacts/${appId}/public/data/training_records/${dateKey}`);
        const currentRecord = records[dateKey] || {};
        const newTypeRecord = { ...(currentRecord[type] || {}) };
        newTypeRecord[item] = !newTypeRecord[item];
        const newData = { ...currentRecord, [type]: newTypeRecord, updatedBy: userId, updatedAt: new Date().toISOString() };
        await setDoc(docRef, newData, { merge: true });
    };
    
    const handleOpenEditModal = (type, item, isNew = false) => setEditModal({ isOpen: true, type, item, isNew });
    const handleCloseEditModal = () => setEditModal({ isOpen: false, type: '', item: '', isNew: false });

    const handleSaveItem = async (type, oldItem, newItem) => {
        if (!newItem || newItem.trim() === '') return;
        const isStretch = type === 'stretch';
        const items = isStretch ? [...stretchItems] : [...workoutItems];
        const oldIndex = items.indexOf(oldItem);

        if (editModal.isNew) {
            if (!items.includes(newItem)) items.push(newItem);
        } else if (oldIndex > -1 && !items.includes(newItem)) {
            items[oldIndex] = newItem;
        }
        
        isStretch ? setStretchItems(items) : setWorkoutItems(items);
        await updateItemsConfig(isStretch ? items : null, isStretch ? null : items);
        handleCloseEditModal();
    };

    const handleDeleteItem = async (type, item) => {
        const isStretch = type === 'stretch';
        const newItems = (isStretch ? stretchItems : workoutItems).filter(i => i !== item);
        isStretch ? setStretchItems(newItems) : setWorkoutItems(newItems);
        await updateItemsConfig(isStretch ? newItems : null, isStretch ? null : newItems);
        handleCloseEditModal();
    };

    const todayRecord = records[formatDate(currentDate)] || {};

    return (
        <div className="bg-lime-50 min-h-screen font-sans text-gray-800 flex flex-col items-center">
            <div className="w-full max-w-md bg-white/80 backdrop-blur-sm flex-grow">
                <Header currentDate={currentDate} onPrevDay={() => changeDate(-1)} onNextDay={() => changeDate(1)} onToggleCalendar={() => setCalendarVisible(!isCalendarVisible)} />
                <main className="p-4 space-y-6">
                    <RecordSection title="ストレッチ" items={stretchItems} records={todayRecord.stretch || {}} onToggle={(item) => handleItemToggle('stretch', item)} icon={<Leaf className="w-6 h-6 text-emerald-600" />} onOpenEditModal={(item, isNew) => handleOpenEditModal('stretch', item, isNew)} />
                    <RecordSection title="筋トレ" items={workoutItems} records={todayRecord.workout || {}} onToggle={(item) => handleItemToggle('workout', item)} icon={<Dumbbell className="w-6 h-6 text-cyan-600" />} onOpenEditModal={(item, isNew) => handleOpenEditModal('workout', item, isNew)} />
                </main>
            </div>
            {isCalendarVisible && <CalendarView records={records} onSelectDate={(date) => { setCurrentDate(date); setCalendarVisible(false); }} onClose={() => setCalendarVisible(false)} />}
            {editModal.isOpen && <EditItemModal modalState={editModal} onClose={handleCloseEditModal} onSave={handleSaveItem} onDelete={handleDeleteItem} />}
        </div>
    );
}

function Header({ currentDate, onPrevDay, onNextDay, onToggleCalendar }) {
    return (
        <header className="bg-white/50 p-4 border-b border-lime-200 sticky top-0 z-10">
            <div className="flex items-center justify-between">
                <button onClick={onPrevDay} className="p-2 rounded-full hover:bg-lime-100 transition-colors"><ChevronLeft className="w-6 h-6 text-gray-600" /></button>
                <button onClick={onToggleCalendar} className="text-center cursor-pointer hover:bg-lime-100 px-3 py-1.5 rounded-lg transition-colors"><h1 className="text-xl font-bold tracking-tight text-gray-700">{getJapaneseDateString(currentDate)}</h1></button>
                <button onClick={onNextDay} className="p-2 rounded-full hover:bg-lime-100 transition-colors"><ChevronRight className="w-6 h-6 text-gray-600" /></button>
            </div>
        </header>
    );
}

function RecordButton({ item, isRecorded, onToggle, onLongPress }) {
    const timerRef = useRef();
    const isLongPressTriggered = useRef(false);

    const handleMouseDown = () => {
        isLongPressTriggered.current = false;
        timerRef.current = setTimeout(() => {
            isLongPressTriggered.current = true;
            onLongPress();
        }, 500);
    };
    const handleMouseUp = () => clearTimeout(timerRef.current);
    const handleClick = () => { if (!isLongPressTriggered.current) onToggle(); };

    return (
        <button
            onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
            onTouchStart={handleMouseDown} onTouchEnd={handleMouseUp}
            onClick={handleClick}
            className={`p-3 text-center rounded-lg shadow-sm transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 select-none
                ${isRecorded
                    ? 'bg-emerald-100 text-emerald-700 font-bold border-2 border-emerald-300'
                    : 'bg-white text-emerald-800 border border-emerald-200 hover:bg-emerald-50'
                }`}
        >{item}</button>
    );
}

function RecordSection({ title, items, records, onToggle, icon, onOpenEditModal }) {
    return (
        <section>
            <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-3">
                    {icon}
                    <h2 className="text-lg font-semibold">{title}</h2>
                </div>
                <button onClick={() => onOpenEditModal('', true)} className="p-1.5 rounded-full hover:bg-lime-200 transition-colors">
                    <Plus className="w-5 h-5 text-gray-500" />
                </button>
            </div>
            <div className="grid grid-cols-3 gap-3">
                {items.map(item => (
                    <RecordButton key={item} item={item} isRecorded={records[item]} onToggle={() => onToggle(item)} onLongPress={() => onOpenEditModal(item, false)} />
                ))}
            </div>
        </section>
    );
}

function CalendarView({ records, onSelectDate, onClose }) {
    const [viewDate, setViewDate] = useState(new Date());
    const { month, year, days } = useMemo(() => {
        const y = viewDate.getFullYear(), m = viewDate.getMonth();
        const firstDay = new Date(y, m, 1).getDay();
        const daysInMonth = new Date(y, m + 1, 0).getDate();
        const dayCells = Array.from({ length: firstDay }, () => null).concat(Array.from({ length: daysInMonth }, (_, i) => new Date(y, m, i + 1)));
        return { month: m, year: y, days: dayCells };
    }, [viewDate]);
    
    const changeMonth = (offset) => setViewDate(prev => { const d = new Date(prev); d.setMonth(d.getMonth() + offset, 1); return d; });
    const getDayStatusIcon = useCallback(date => {
        if (!date) return null;
        const record = records[formatDate(date)];
        if (!record) return null;
        const didStretch = Object.values(record.stretch || {}).some(Boolean);
        const didWorkout = Object.values(record.workout || {}).some(Boolean);
        if (didStretch && didWorkout) return <div className="flex justify-center items-center gap-0.5"><Leaf className="w-3.5 h-3.5 text-emerald-500" /><Dumbbell className="w-3.5 h-3.5 text-cyan-500" /></div>;
        if (didStretch) return <Leaf className="w-4 h-4 text-emerald-500" />;
        if (didWorkout) return <Dumbbell className="w-4 h-4 text-cyan-500" />;
        return null;
    }, [records]);
    const isToday = date => date && formatDate(date) === formatDate(new Date());

    return (
        <div className="fixed inset-0 bg-black bg-opacity-40 z-20 flex justify-center items-center" onClick={onClose}>
            <div className="bg-white rounded-2xl shadow-2xl p-4 w-11/12 max-w-sm" onClick={e => e.stopPropagation()}>
                <div className="flex items-center justify-between mb-3">
                    <button onClick={() => changeMonth(-1)} className="p-2 rounded-full hover:bg-gray-100"><ChevronLeft className="w-5 h-5" /></button>
                    <h3 className="font-bold text-lg">{`${year}年 ${month + 1}月`}</h3>
                    <button onClick={() => changeMonth(1)} className="p-2 rounded-full hover:bg-gray-100"><ChevronRight className="w-5 h-5" /></button>
                </div>
                <div className="grid grid-cols-7 gap-1 text-center text-sm">
                    {['日', '月', '火', '水', '木', '金', '土'].map(d => <div key={d} className="font-medium text-gray-500 pb-2">{d}</div>)}
                    {days.map((date, i) => (
                        <div key={i} className="flex justify-center items-center h-12">
                            {date && (<button onClick={() => onSelectDate(date)} className={`w-10 h-10 flex flex-col justify-center items-center rounded-full transition-colors ${isToday(date) ? 'bg-emerald-100 text-emerald-700 font-bold' : 'hover:bg-gray-100'}`}>
                                <span>{date.getDate()}</span>
                                <div className="h-4 mt-0.5">{getDayStatusIcon(date)}</div>
                            </button>)}
                        </div>
                    ))}
                </div>
            </div>
        </div>
    );
}

function EditItemModal({ modalState, onClose, onSave, onDelete }) {
    const { type, item, isNew } = modalState;
    const [name, setName] = useState(item);

    const title = isNew ? "項目を追加" : "項目を編集";
    const saveButtonText = isNew ? "追加" : "保存";
    
    const handleSave = (e) => {
      e.preventDefault();
      onSave(type, item, name.trim());
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-30 flex justify-center items-center" onClick={onClose}>
            <div className="bg-white rounded-2xl shadow-2xl p-6 w-11/12 max-w-xs" onClick={e => e.stopPropagation()}>
                <h3 className="text-xl font-bold text-center mb-4">{title}</h3>
                <form onSubmit={handleSave}>
                    <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg mb-4 focus:ring-2 focus:ring-emerald-400 focus:outline-none"
                        placeholder="項目名"
                        autoFocus
                    />
                    <div className="grid grid-cols-2 gap-3">
                        <button type="button" onClick={onClose} className="w-full py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors">キャンセル</button>
                        <button type="submit" className="w-full py-2 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 transition-colors">{saveButtonText}</button>
                    </div>
                </form>
                {!isNew && (
                    <button onClick={() => onDelete(type, item)} className="w-full mt-4 text-red-500 text-sm hover:underline">
                        この項目を削除する
                    </button>
                )}
            </div>
        </div>
    );
}



